//! Integration tests for Milestone 4 Callable Catalog functionality.

use gql_parser::semantic::callable::{
    lookup_builtin_callable, resolve_builtin_signatures, list_builtin_callables,
    CallableKind, CallableSignature, CallableValidator, DefaultCallableValidator,
    ParameterSignature, Volatility, Nullability,
};
use gql_parser::semantic::{SemanticValidator, ValidationConfig};

#[test]
fn test_builtin_callable_coverage() {
    // Test that all standard GQL built-ins are available

    // Numeric functions
    assert!(resolve_builtin_signatures("abs", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("mod", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("floor", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("ceil", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("sqrt", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("power", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("exp", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("ln", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("log", CallableKind::Function).is_some());

    // String functions
    assert!(resolve_builtin_signatures("upper", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("lower", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("trim", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("substring", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("length", CallableKind::Function).is_some());

    // Temporal functions
    assert!(resolve_builtin_signatures("current_date", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("current_time", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("current_timestamp", CallableKind::Function).is_some());

    // Aggregate functions
    assert!(resolve_builtin_signatures("count", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("sum", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("avg", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("min", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("max", CallableKind::AggregateFunction).is_some());

    // Utility functions
    assert!(resolve_builtin_signatures("coalesce", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("nullif", CallableKind::Function).is_some());
}

#[test]
fn test_builtin_function_signatures() {
    // Test that built-in function signatures can be resolved
    // Built-ins are always available (checked directly by validator)

    // Test numeric functions
    assert!(resolve_builtin_signatures("abs", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("mod", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("floor", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("ceil", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("sqrt", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("power", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("exp", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("ln", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("log", CallableKind::Function).is_some());

    // Test string functions
    assert!(resolve_builtin_signatures("length", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("substring", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("upper", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("lower", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("trim", CallableKind::Function).is_some());

    // Test temporal functions
    assert!(resolve_builtin_signatures("current_date", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("current_time", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("current_timestamp", CallableKind::Function).is_some());

    // Test aggregate functions
    assert!(resolve_builtin_signatures("count", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("sum", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("avg", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("min", CallableKind::AggregateFunction).is_some());
    assert!(resolve_builtin_signatures("max", CallableKind::AggregateFunction).is_some());

    // Test other functions
    assert!(resolve_builtin_signatures("coalesce", CallableKind::Function).is_some());
    assert!(resolve_builtin_signatures("nullif", CallableKind::Function).is_some());
}

#[test]
fn test_builtin_function_arity() {
    // Built-ins are always available (checked directly by validator)

    // ABS: requires exactly 1 argument
    let sigs = resolve_builtin_signatures("abs", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].min_arity(), 1);
    assert_eq!(sigs[0].max_arity(), Some(1));

    // MOD: requires exactly 2 arguments
    let sigs = resolve_builtin_signatures("mod", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].min_arity(), 2);
    assert_eq!(sigs[0].max_arity(), Some(2));

    // SUBSTRING: requires 2-3 arguments (third is optional)
    let sigs = resolve_builtin_signatures("substring", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].min_arity(), 2);
    assert_eq!(sigs[0].max_arity(), Some(3));

    // ROUND: requires 1-2 arguments (second is optional)
    let sigs = resolve_builtin_signatures("round", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].min_arity(), 1);
    assert_eq!(sigs[0].max_arity(), Some(2));

    // CONCAT: variadic (unlimited arguments)
    let sigs = resolve_builtin_signatures("concat", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].max_arity(), None); // variadic

    // COALESCE: variadic
    let sigs = resolve_builtin_signatures("coalesce", CallableKind::Function).unwrap();
    assert_eq!(sigs[0].max_arity(), None); // variadic
}

#[test]
fn test_default_callable_validator_correct_arity() {
    use gql_parser::ast::Span;
    use gql_parser::semantic::callable::CallSite;

    let validator = DefaultCallableValidator::new();

    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![ParameterSignature::required("x", "INT")],
        Some("INT"),
    );

    // Correct arity
    let call = CallSite {
        name: "test",
        kind: CallableKind::Function,
        arg_count: 1,
        span: 0..4,
    };

    let diags = validator.validate_call(&call, &[sig]);
    assert!(diags.is_empty());
}

#[test]
fn test_default_callable_validator_wrong_arity() {
    use gql_parser::ast::Span;
    use gql_parser::diag::DiagSeverity;
    use gql_parser::semantic::callable::CallSite;

    let validator = DefaultCallableValidator::new();

    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![ParameterSignature::required("x", "INT")],
        Some("INT"),
    );

    // Wrong arity: too many arguments
    let call = CallSite {
        name: "test",
        kind: CallableKind::Function,
        arg_count: 2,
        span: 0..4,
    };

    let diags = validator.validate_call(&call, &[sig.clone()]);
    assert_eq!(diags.len(), 1);
    assert_eq!(diags[0].severity, DiagSeverity::Error);
    assert!(diags[0].message.contains("expects"));

    // Wrong arity: too few arguments
    let call = CallSite {
        name: "test",
        kind: CallableKind::Function,
        arg_count: 0,
        span: 0..4,
    };

    let diags = validator.validate_call(&call, &[sig]);
    assert_eq!(diags.len(), 1);
    assert_eq!(diags[0].severity, DiagSeverity::Error);
}

#[test]
fn test_default_callable_validator_undefined_function() {
    use gql_parser::ast::Span;
    use gql_parser::diag::DiagSeverity;
    use gql_parser::semantic::callable::CallSite;

    let validator = DefaultCallableValidator::new();

    let call = CallSite {
        name: "undefined_func",
        kind: CallableKind::Function,
        arg_count: 1,
        span: 0..14,
    };

    // Empty signature list means function not found
    let diags = validator.validate_call(&call, &[]);
    assert_eq!(diags.len(), 1);
    assert_eq!(diags[0].severity, DiagSeverity::Error);
    assert!(diags[0].message.contains("not defined"));
}

#[test]
fn test_default_callable_validator_variadic() {
    use gql_parser::ast::Span;
    use gql_parser::semantic::callable::CallSite;

    let validator = DefaultCallableValidator::new();

    let sig = CallableSignature::new(
        "concat",
        CallableKind::Function,
        vec![ParameterSignature::variadic("args", "STRING")],
        Some("STRING"),
    );

    // Variadic accepts any number of arguments >= min_arity
    for arg_count in 0..10 {
        let call = CallSite {
            name: "concat",
            kind: CallableKind::Function,
            arg_count,
            span: 0..6,
        };

        let diags = validator.validate_call(&call, &[sig.clone()]);
        assert!(diags.is_empty(), "Failed for arg_count={}", arg_count);
    }
}

#[test]
fn test_semantic_validator_with_callable_catalog() {
    // Built-ins are always available (checked directly by validator)

    let _validator = SemanticValidator::new();

    // Just verify it compiles and can be constructed
}

#[test]
fn test_callable_validation_config_defaults() {
    let config = ValidationConfig::default();
    assert!(!config.metadata_validation);
}

#[test]
fn test_signature_arity_helpers() {
    // Fixed arity
    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![
            ParameterSignature::required("a", "INT"),
            ParameterSignature::required("b", "INT"),
        ],
        Some("INT"),
    );
    assert_eq!(sig.min_arity(), 2);
    assert_eq!(sig.max_arity(), Some(2));
    assert!(sig.matches_arity(2));
    assert!(!sig.matches_arity(1));
    assert!(!sig.matches_arity(3));

    // With optional parameter
    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![
            ParameterSignature::required("a", "INT"),
            ParameterSignature::optional("b", "INT"),
        ],
        Some("INT"),
    );
    assert_eq!(sig.min_arity(), 1);
    assert_eq!(sig.max_arity(), Some(2));
    assert!(sig.matches_arity(1));
    assert!(sig.matches_arity(2));
    assert!(!sig.matches_arity(0));
    assert!(!sig.matches_arity(3));

    // Variadic
    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![ParameterSignature::variadic("args", "ANY")],
        Some("ANY"),
    );
    assert_eq!(sig.min_arity(), 0);
    assert_eq!(sig.max_arity(), None);
    assert!(sig.matches_arity(0));
    assert!(sig.matches_arity(1));
    assert!(sig.matches_arity(100));

    // Required + variadic
    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![
            ParameterSignature::required("first", "INT"),
            ParameterSignature::variadic("rest", "INT"),
        ],
        Some("INT"),
    );
    assert_eq!(sig.min_arity(), 1);
    assert_eq!(sig.max_arity(), None);
    assert!(!sig.matches_arity(0));
    assert!(sig.matches_arity(1));
    assert!(sig.matches_arity(100));
}

#[test]
fn test_callable_lookup_context_builder() {
    let ctx = CallableLookupContext::new();
    assert!(ctx.include_builtins);
    assert!(ctx.schema.is_none());
    assert!(ctx.graph.is_none());

    let ctx = CallableLookupContext::new()
        .with_schema("my_schema")
        .with_graph("my_graph")
        .with_builtins(false);

    assert!(!ctx.include_builtins);
    assert_eq!(ctx.schema, Some("my_schema".into()));
    assert_eq!(ctx.graph, Some("my_graph".into()));
}

#[test]
fn test_parameter_signature_constructors() {
    let param = ParameterSignature::required("x", "INT");
    assert!(!param.optional);
    assert!(!param.variadic);
    assert_eq!(param.name, "x");
    assert_eq!(param.param_type, "INT");

    let param = ParameterSignature::optional("y", "STRING");
    assert!(param.optional);
    assert!(!param.variadic);

    let param = ParameterSignature::variadic("args", "ANY");
    assert!(!param.optional);
    assert!(param.variadic);
}

#[test]
fn test_callable_signature_builder() {
    use gql_parser::semantic::callable::{Nullability, Volatility};

    let sig = CallableSignature::new(
        "test",
        CallableKind::Function,
        vec![ParameterSignature::required("x", "INT")],
        Some("INT"),
    )
    .with_volatility(Volatility::Volatile)
    .with_nullability(Nullability::CalledOnNullInput);

    assert_eq!(sig.volatility, Volatility::Volatile);
    assert_eq!(sig.nullability, Nullability::CalledOnNullInput);
}

#[test]
fn test_builtin_catalog_case_insensitive() {
    // Built-ins are always available (checked directly by validator)

    // Test case insensitivity
    let sigs_lower = resolve_builtin_signatures("abs", CallableKind::Function).unwrap();
    let sigs_upper = resolve_builtin_signatures("ABS", CallableKind::Function).unwrap();
    let sigs_mixed = resolve_builtin_signatures("AbS", CallableKind::Function).unwrap();

    assert_eq!(sigs_lower.len(), sigs_upper.len());
    assert_eq!(sigs_lower.len(), sigs_mixed.len());
}

#[test]
fn test_inmemory_catalog_case_insensitive() {
    let mut catalog = InMemoryCallableCatalog::new();
    let ctx = CallableLookupContext::new();

    catalog.register(CallableSignature::new(
        "MyFunc",
        CallableKind::Function,
        vec![],
        Some("INT"),
    ));

    // Should resolve regardless of case
    assert!(!catalog
        .resolve("myfunc", CallableKind::Function, &ctx)
        .unwrap()
        .is_empty());
    assert!(!catalog
        .resolve("MYFUNC", CallableKind::Function, &ctx)
        .unwrap()
        .is_empty());
    assert!(!catalog
        .resolve("MyFunc", CallableKind::Function, &ctx)
        .unwrap()
        .is_empty());
}
